#!/usr/bin/env python3
# /// script
# requires-python = "~=3.12"
# dependencies = [
#     "requests",
#     "typer",
# ]
# ///
import logging
import os
import shlex
import subprocess
from pathlib import Path

import typer
import yaml

from sbom import ArtifactType, SBOMber, DEFAULT_SERVICE_URL

logger = logging.getLogger("sbomber")
DEFAULT_SBOMBERPATH = Path(__file__).parent.resolve()
DEFAULT_STATEFILE = DEFAULT_SBOMBERPATH / "sbom_statefile.yaml"
DEFAULT_MANIFEST = DEFAULT_SBOMBERPATH / "sbom_manifest.yaml"
DEFAULT_REPORTS_DIR = DEFAULT_SBOMBERPATH / "reports"
DEFAULT_PACKAGE_DIR = DEFAULT_SBOMBERPATH / "pgks"


def _prepare(
        manifest: Path = DEFAULT_MANIFEST,
        statefile: Path = DEFAULT_STATEFILE,
        pkg_dir: Path = DEFAULT_PACKAGE_DIR):
    meta = yaml.safe_load(manifest.read_text())
    try:
        artifacts = meta['artifacts']
    except KeyError:
        exit("invalid manifest file: must contain `artifacts`.")

    cd = os.getcwd()
    # in case juju doesn't let us download straight to the pkg dir,
    # we could download all to ./ and later copy (mv?) to pkg_dir?
    pkg_dir.mkdir(exist_ok=True)
    os.chdir(pkg_dir)

    for artifact in artifacts:
        def _download_cmd(bin: str, artifact):
            channel_arg = f" --channel {channel}" if (channel := artifact.get("channel")) else ""
            revision_arg = f" --revision {revision}" if (revision := artifact.get("revision")) else ""
            progress_arg = f" --no-progress" if bin == "juju" else ""
            return shlex.split(f"{bin} download {artifact['name']}{progress_arg}{channel_arg}{revision_arg}")

        try:
            type = artifact['type']
            if type == "local":
                print(f"fetching local archive {artifact}")
                path = Path(artifact["name"])
                (Path() / path.name).write_bytes(path.read_bytes())
                obj_name = path.name

            elif type == "charm":
                print(f"fetching charm {artifact}")
                proc = subprocess.run(_download_cmd("juju", artifact), capture_output=True, text=True)
                # example output is:
                # Fetching charm "parca-k8s" revision 299
                # Install the "parca-k8s" charm with:
                #     juju deploy ./parca-k8s_r299.charm

                # fetch "parca-k8s_r299.charm"

                # for whatever fucking reason this goes to stderr
                obj_name = proc.stderr.splitlines()[-1].split()[-1][2:]

            elif type == "snap":
                print(f"fetching snap {artifact}")

                proc = subprocess.run(_download_cmd("snap", artifact), capture_output=True, text=True)

                # example output is:
                # Fetching snap "jhack"
                # Fetching assertions for "jhack"
                # Install the snap with:
                #    snap ack jhack_445.assert
                #    snap install jhack_445.snap

                # fetch "jhack_445.snap"
                obj_name = proc.stdout.splitlines()[-1].split()[-1]

            else:
                raise ValueError(f"unsupported type {type}")

        except TypeError:
            exit(f"Invalid artifact spec: {artifact}")

        artifact['object'] = obj_name

    logger.debug("cleaning up snap .assert files")
    for path in Path().glob("*.assert"):
        path.unlink()

    os.chdir(cd)

    logger.info(f"creating statefile: {statefile}")
    statefile.write_text(yaml.safe_dump(meta))

    print(f"all ready in {pkg_dir.absolute()}.")


def _submit(statefile: Path = DEFAULT_STATEFILE,
            pkg_dir: Path = DEFAULT_PACKAGE_DIR):
    meta = yaml.safe_load(statefile.read_text())
    try:
        email = meta['email']
        department = meta['department']
        team = meta['team']
    except KeyError:
        exit("invalid statefile: must contain all of `email, department, team`.")

    if not pkg_dir.exists():
        exit("no pkg_dir dir found: run `prepare` first.")

    sbomber = SBOMber(
        email=email,
        department=department,
        team=team,
        service_url=meta.get("service-url")
    )

    artifact_ids = []

    for artifact in meta['artifacts']:
        obj = artifact.get("object", "")
        obj_path = pkg_dir / obj
        if not obj or not obj_path.exists() or not obj_path.is_file():
            exit(f"invalid `object` field for artifact {artifact['name']!r}. Have you run `prepare`?")

        artifact_id = sbomber.request_sbom(obj_path, 1)
        print(f"{artifact['name']} requested as ID: {artifact_id}")

        artifact_ids.append(artifact_id)

        requests = artifact.get('requests', {})
        requests[artifact_id] = "Started"
        artifact["requests"] = requests

    logger.debug("updating statefile")
    statefile.write_text(yaml.safe_dump(meta))

    print("requested SBOMBs for all artifacts")


def _poll(statefile: Path = "./sbom_statefile.yaml",
          wait: bool = False,
          timeout: int = 15):
    meta = yaml.safe_load(statefile.read_text())
    try:
        email = meta['email']
        department = meta['department']
        team = meta['team']
    except KeyError:
        exit("invalid statefile: must contain all of `email, department, team`.")
    try:
        artifacts = meta['artifacts']
    except KeyError:
        exit("invalid statefile: must contain `artifacts`.")

    sbomber = SBOMber(
        email=email,
        department=department,
        team=team,
        service_url=meta.get("service-url")
    )

    print("artifact :: status")
    # block until all are completed
    for artifact in artifacts:
        requests = artifact.get('requests', {})
        if not requests:
            logger.error(f"artifact {artifact['name']} has no requests.")
            continue

        for artifact_id in requests:
            logger.info(f"polling {artifact_id}...")
            if wait:
                try:
                    status = "Completed"
                    sbomber.wait(artifact_id, status=status, timeout=timeout)
                except TimeoutError:
                    logger.error(f"timeout waiting for {artifact_id}")
                    status = "Pending"
            else:
                status = sbomber.query_status(artifact_id)
            print(f"\t{artifact_id}\t{status}")
            requests[artifact_id] = status

    logger.debug("updating statefile")
    statefile.write_text(yaml.safe_dump(meta))


def _download(statefile: Path = DEFAULT_STATEFILE, reports_dir=DEFAULT_REPORTS_DIR):
    meta = yaml.safe_load(statefile.read_text())
    try:
        email = meta['email']
        department = meta['department']
        team = meta['team']
    except KeyError:
        exit("invalid statefile: must contain all of `email, department, team`.")
    try:
        artifacts = meta['artifacts']
    except KeyError:
        exit("invalid statefile: must contain `artifacts`.")

    sbomber = SBOMber(
        email=email,
        department=department,
        team=team,
        service_url=meta.get("service-url")
    )

    for artifact in artifacts:
        requests = artifact.get('requests', {})
        if not requests:
            logger.error(f"artifact {artifact['name']} has no requests.")
            continue

        for artifact_id, status in requests.items():
            if status != "Completed":
                logger.error("attempting to download a non-completed artifact may not work. "
                             "Consider `polling` first.")

            location = reports_dir / (artifact_id + ".sbom")
            try:
                sbomber.download_report(artifact_id, location)
            except Exception:
                logger.error(f"error downloading SBOM for {artifact_id}.")
                requests[artifact_id] = "Error"
                continue

            print(f"downloaded SBOM for {artifact_id} to {location}")

        logger.debug("updating statefile")
        statefile.write_text(yaml.safe_dump(meta))
        print(f"all downloaded SBOMs ready in {reports_dir}")


def main():
    """Sbomber CLI."""
    app = typer.Typer(no_args_is_help=True)

    @app.command()
    def e2e(
            email: str = typer.Argument(
                ...,
                help="The email to notify when the build is ready."
            ),
            department: str = typer.Argument(
                ...,
                help="The department this build belongs to."
            ),
            team: str = typer.Argument(
                ...,
                help="The team this build belongs to."
            ),
            service_url: str = typer.Argument(
                DEFAULT_SERVICE_URL,
                help="The service URL to send API requests to."
            ),
            artifact: Path = typer.Argument(
                ...,
                help="The artifact whose SBOM you want to generate. "
                     f"Currently supported: ({list(ArtifactType)})."
            ),
            version: str = typer.Argument("0", help="Artifact version to associate with the build.")
    ):
        sbomber = SBOMber(
            email=email,
            department=department,
            team=team,
            service_url=service_url

        )

        sbomber.sbomb(
            artifact,
            version=version
        )

    parallel = typer.Typer(help="Parallel sbombing tools.")

    @parallel.command()
    def prepare(
            manifest: Path = typer.Argument(
                DEFAULT_MANIFEST,
                help="Path to a manifest file containing the required metadata."
            ),
            statefile: Path = typer.Argument(
                DEFAULT_STATEFILE,
                help="Path to statefile which will be created to hold the sbomber state."
            ),
            pkg_dir: Path = typer.Option(
                DEFAULT_PACKAGE_DIR,
                help="Folder where the collected artifacts will be gathered before uploading them.")
    ):
        return _prepare(manifest=manifest, statefile=statefile, pkg_dir=pkg_dir)

    @parallel.command()
    def submit(
            statefile: Path = typer.Argument(
                DEFAULT_STATEFILE,
                help="Path to a statefile holding the sbomber state."
            ),
            pkg_dir: Path = typer.Option(
                DEFAULT_PACKAGE_DIR,
                help="Folder where the collected artifacts will be gathered before uploading them.")

    ):
        return _submit(statefile=statefile, pkg_dir=pkg_dir)

    @parallel.command()
    def poll(
            statefile: Path = typer.Argument(
                DEFAULT_STATEFILE,
                help="Path to a statefile holding the sbomber state."
            ),
            wait: bool = typer.Option(
                False,
                is_flag=True,
                help="Wait for all sboms to be in Completed state before exiting."
            ),
            timeout: int = typer.Option(
                15,
                is_flag=True,
                help="Timeout (in minutes) for artifact completion (per artifact)."
            )
    ):
        return _poll(statefile=statefile, wait=wait, timeout=timeout)

    @parallel.command()
    def download(
            statefile: Path = typer.Argument(
                DEFAULT_STATEFILE,
                help="Path to a statefile holding the sbomber state."
            ),
            reports_dir: Path = typer.Option(
                DEFAULT_REPORTS_DIR,
                help="Directory in which to drop all downloaded sbombs."
            )
    ):
        return _download(
            statefile=statefile, reports_dir=reports_dir
        )

    app.add_typer(parallel)

    app()


if __name__ == '__main__':
    main()
